# PowAlgorithm
pow工作量证明机制(proof of work)：系统出一道难于运算易于验证的证明题，证明者提交答案，任何人通过验证这个答案就能得到奖励。
证明题一般是完成一次符合条件的一次hash碰撞  
挖矿所做的事就是在Pow  

本次实验就是利用pow机制去挖矿，生成新的区块  
java的简单实现  
在区块中先介绍下几个属性:  
属性                    说明  
preHash                前一个hash的区块  
hashCode               当前区块的hash  
timestmp               时间戳  
diff                   困难难度系数，前导0个数  
data                   存交易信息  
index                  区块高度  
nonce                  随机值  
这里着重说明一下diff这个值，这个值是用来做难度系数的确定，下一个区块生成的时候会根据当前的挖矿的人数等信息决定此次挖矿的难度。这个难度值就是diff。也就是前导零的个数。  
如果通过随机值nonce生成的hash值的前{diff}位是0。那么就是挖矿成功。  
  
 本次实验只是简单的做了一个pow共识算法，diff设置为一个固定值4.随机数nonce也只是按递增的顺序。  
首先是创建了一个初始区块。验证区块的创建成功，后面就可以进行挖矿了。  
  
  关于新区块的hash怎么确定呢？这里就用到了我们的PoW证明机制。对于这个机制，我们需要传入刚刚的新区块和diff值。  
  这里简单的模拟一下这个机制，首先getPrefix0根据diff获取前导0的个数将其转为前缀字符串，以方便匹配到正确的hash。接着我们就死循环的利用不同的随机值去得到信息hash值。判断这个hash值符不符合要求，符合就返回这个hash。  
  由于diff是4，大约几万次hash就能碰撞到了。
  这是输出结果  
  输出：挖矿成功  
{preHash=‘3012930ae2d63e48641049163231af9778c5b20d46b327a3c4eb157b38254279’, hashCode=‘0000f8847f1a2211753ba5a6c18ac073866a376cef79e2a5cf0fed48dae4a733’, timestamp=2019-12-26 15:16:54.901, diff=4, data=‘第二个区块’, index=2, nonce=43485}   

  
  
  


